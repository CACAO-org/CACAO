<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>cacao: Setting up the hardware interfaces</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="cacao-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">cacao
   &#160;<span id="projectnumber">Alpha Release 0.1.0</span>
   </div>
   <div id="projectbrief">Compute And Control For Adaptive Optics</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_src_AOloopControl_doc_AOloopControl_guide.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Setting up the hardware interfaces </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Top level script</h2>
<p>Start aolconf with loop number and loop name (you can ommit these arguments when launching the script again):</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;./aolconf -L 3 -N testsim</div>
</div><!-- fragment --><p>The loop name (<code>testsim</code> in the above example) will both allocate a name for the loop and execute an optional custom setup script. The software package comes with a few such pre-made custom scripts for specific systems / examples. When the <code>-N</code> option is specified, the custom setup script <code>./setup/setup_&lt;name&gt;</code> is ran. The script may make some of the steps described below optional.</p>
<p>You can check the current loop number and name settings with:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;./aolconf -h</div>
</div><!-- fragment --><p>The script can also launch a pre-written CPU/OS configuration script named <code>./aocscripts/cpuconfig_&lt;LOOPNAME&gt;</code> :</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;./aolconf -C</div>
</div><!-- fragment --><h2>Setting the DM interface</h2>
<p>There are four options for setting up the DM:</p>
<ul>
<li>[A] Connect to an existing DM</li>
<li>[B] Create a new DM and connect to it</li>
<li>[C] Create a new modal DM, mapped to an existing DM using another loop's control modes</li>
<li>[D] Create a new modal DM, mapped to an existing DM channel using a custom set of modes</li>
</ul>
<p>Before choosing an option, select if the DM to be controlled is <code>MODAL</code> or <code>ZONAL</code>. A zonal DM is one where the DM pixel locations map to physical actuator locations on the DM, allowing spatial filtering when creating control modes. With a zonal DM, each pixel of the DM map corresponds to a wavefront control mode, and spatial filtering functions are turned off.</p>
<p>Options [C] and [D] are <code>MODAL</code> options, as the DM does not represent physical spatial actuators. These options build a virtual DM which controls another DM.</p>
<h3>Mode [A]: Connecting to an existing DM</h3>
<ol type="1">
<li><b>Set DM number</b> (<code>S</code> command in <code>Top Menu</code> screen). You should see its x and y size in the two lines below. If not, the DM does not exist yet (see next section).</li>
<li><b>autoconfigure DM: main DM (nolink)</b> (<code>nolink</code> in <code>Top Menu</code> screen). This command automactically sets up the following symbolic links:<ul>
<li>dm##disp00 is linked to aol::_dmO (flat offset channel)</li>
<li>dm##disp02 is linked to aol::_dmRM (response matrix actuation channel)</li>
<li>dm##disp03 is linked to aol::_dmC (loop dm control channel)</li>
<li>dm##disp04 is linked to aol::_dmZP0 (zero point offset 0 actuation channel)</li>
<li>dm##disp05 is linked to aol::_dmZP1 (zero point offset 1 actuation channel)</li>
<li>dm##disp06 is linked to aol::_dmZP2 (zero point offset 2 actuation channel)</li>
<li>dm##disp07 is linked to aol::_dmZP3 (zero point offset 3 actuation channel)</li>
<li>dm##disp08 is linked to aol::_dmZP4 (zero point offset 4 actuation channel)</li>
<li>dm##disp is linked to aol::_dmdisp (total dm displacement channel)</li>
</ul>
</li>
<li><b>load Memory</b> (<code>M</code> in <code>Top Menu</code> screen). The dm performs the symbolic links to the DM channels.</li>
</ol>
<h3>Mode [B]: Creating and Connecting to a DM</h3>
<ol type="1">
<li>Set <b>DM number</b> (<code>S</code> command in <code>Top Menu</code> screen).</li>
<li>Enter the desired <b>DM size</b> with the <code>dmxs</code> and <code>dmys</code> commands.</li>
</ol>
<ul>
<li>OPTIONAL: <b>set DM delay</b> ('setDMdelayON' and 'setDMdelayval' in <code>Top Menu</code> screen)</li>
</ul>
<ol type="1">
<li><b>Create the DM streams</b> with the <code>initDM</code> command in the <code>Top Menu</code>. You may need to run the <code>stopDM</code> command first.</li>
<li><b>autoconfigure DM: main DM (nolink)</b> (<code>nolink</code> in <code>Top Menu</code> screen). This command automactically sets up the following symbolic links:<ul>
<li>dm##disp00 is linked to aol::_dmO (flat offset channel)</li>
<li>dm##disp02 is linked to aol::_dmRM (response matrix actuation channel)</li>
<li>dm##disp03 is linked to aol::_dmC (loop dm control channel)</li>
<li>dm##disp04 is linked to aol::_dmZP0 (zero point offset 0 actuation channel)</li>
<li>dm##disp05 is linked to aol::_dmZP1 (zero point offset 1 actuation channel)</li>
<li>dm##disp06 is linked to aol::_dmZP2 (zero point offset 2 actuation channel)</li>
<li>dm##disp07 is linked to aol::_dmZP3 (zero point offset 3 actuation channel)</li>
<li>dm##disp08 is linked to aol::_dmZP4 (zero point offset 4 actuation channel)</li>
<li>dm##disp is linked to aol::_dmdisp (total dm displacement channel)</li>
</ul>
</li>
<li><b>Load Memory</b> (<code>M</code> in <code>Top Menu</code> screen). The dm performs the symbolic links to the DM channels.</li>
</ol>
<h3>Mode [C]: Create a new modal DM, mapped to an existing DM using another loop's control modes</h3>
<p>In this mode, the AO loop controls a virtual DM. The virtual actuators are correspond to modes controlling the zero point offset of another loop. In this section, I assume that <b>loopA</b> is the main loop (directly controls a physical DM) and that <b>loopB</b> is the virtual loop (this is the loop we are setting up).</p>
<ol type="1">
<li>Select <b>MODAL</b> DM (<code>DMmodeZ</code> in <code>Top Menu</code> screen)</li>
<li>Set <b>DM number</b> (<code>S</code> command in <code>Top Menu</code> screen). This is the DM index for loopB.</li>
<li>Set <b>DM x size</b> to the number of modes of loop A to be addressed by loop B's virtual DM</li>
<li>Set <b>DM y size</b> to 1</li>
<li><b>Auto-configure: DM output linked to other loop</b> (<code>dmolink</code> in <code>Top Menu</code> screen).<ol type="a">
<li>choose loop index from which modes will be extracted (loop A index)</li>
<li>choose offset channel in output loop This will set up several key parameters and files:</li>
</ol>
<ul>
<li><b>DM-to-DM</b> mode will be set to 1, and associated streams:<ul>
<li><b>dm2dmM</b> : <b>loopA</b> modes controlled by <b>loopB</b></li>
<li><b>dm2dmO</b> : symbolic link to <b>loopA</b> DM channel controlled by <b>loopB</b></li>
</ul>
</li>
<li><b>CPU-based dmcomb output WFS ref</b> will be set to 1, and associated streams:<ul>
<li><b>dmwrefRM</b> : <b>loopA</b> WFS response to modes controlled by <b>loopB</b></li>
<li><b>dmwrefO</b> : <b>loopA</b> WFS zero point offset</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><b>OPTIONAL: set DM delay</b> ('setDMdelayON' and 'setDMdelayval' in <code>Top Menu</code> screen)</li>
</ul>
<ol type="1">
<li><b>Create the DM streams</b> with the <code>initDM</code> command in the <code>Top Menu</code>.</li>
<li><b>Load Memory</b> (<code>M</code> in <code>Top Menu</code> screen). The dm performs the symbolic links to the DM channels.</li>
</ol>
<h3>Mode [D]: Create a new modal DM, mapped to an existing DM channel using a custom set of modes</h3>
<p>In this mode, the AO loop controls a virtual DM. The virtual actuators correspond to modes controlling another DM stream. In this section, I assume that <b>loop A</b> is the main loop (directly controls a physical DM) and that <b>loop B</b> is the virtual (higher level) loop.</p>
<ol type="1">
<li>Choose DM index number (<code>S</code>) for loop B</li>
<li>Select number of loop A modes controlled by loop B. The number is entered as DM x size (<code>dmxs</code> in <code>Top menu</code>)</li>
<li>Enter 1 for DM y size (<code>dmys</code> in <code>Top menu</code>)</li>
<li>Set <b>DM-to-DM</b> mode to 1, and associated streams:<ul>
<li><b>dm2dmM</b> : loop A modes controlled by loop B</li>
<li><b>dm2dmO</b> : symbolic link to loop A DM channel controlled by loop B</li>
</ul>
</li>
<li>Set <b>CPU-based dmcomb output WFS ref</b> to 0 (see section below more enabling this option)</li>
<li>**(Re)-create DM streams and run DMcomb process** (<code>initDM</code>)</li>
<li><b>Load Memory</b> (<code>M</code> in <code>Top Menu</code> screen). The dm performs the symbolic links to the DM channels.</li>
</ol>
<p>Commands to the loop B DM should now propagate to modal commands to loop A.</p>
<h3>Option: WFS Zero point offset</h3>
<p>It is possible to add a zero point offset to mode D. Every write to the loop B's modal DM then generate both a write to loop A's DM (described above) and a write to the reference of a wavefront sensor (presumably loop A's wavefront sensor). This optional feature is refered to as a CPU-based WFS zero point offset.</p>
<p>To enable this feature, add between steps 4 and 5:</p>
<ol type="1">
<li>set <b>CPU-based dmcomb output WFS ref</b> to 1, and associated streams:<ul>
<li><b>dmwrefRM</b> : <b>loopA</b> WFS response to modes controlled by <b>loopB</b></li>
<li><b>dmwrefO</b> : <b>loopA</b> WFS zero point offset</li>
</ul>
</li>
</ol>
<h3>Notes</h3>
<p>You can (Re-)Start DM comb to re-initialize arrays and links ('stopDM' and 'initDM' commands in <code>Top Menu</code> screen). The <code>initDM</code> command will</p>
<ul>
<li>(re-)create shared memory streams dm##disp00 to dm##disp11</li>
<li>start the dmcomb process, which adds the dm##disp## channels to create the overall dm##disp displacement</li>
<li>create poke mask and maps</li>
</ul>
<h2>Setting the camera interface</h2>
<ul>
<li><b>link to WFS camera</b> (<code>wfs</code> to <code>Loop Configuration</code> screen). Select the WFS shared memory stream.</li>
</ul>
<h2>Setup script</h2>
<p>An <code>aosetup</code> script may be used to perform all these operations. Inspect the content of directory <code>aosetup</code> to see such scripts. You may use or modify as needed. If you use a <code>aosetup</code> script, execute it from the working directory, and then start aolconf:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;./aosetup/aosetup_&lt;myLoop&gt;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;./aolconf</div>
</div><!-- fragment --><h1>Calibration</h1>
<h2>Acquiring a zonal response matrix</h2>
<ul>
<li><b>set response matrix parameters</b> in <code>Loop Configure</code> screen: amplitude, time delay, frame averaging, excluded frames</li>
<li><b>set normalization and Hadmard modes</b> in <code>Loop Configure</code> screen. Normalization should probably be set to 1.</li>
<li><b>start zonal response matrix acquisition</b> (<code>zrespon</code> in <code>Loop Configure</code> screen). The process runs in tmux session aol::zrepM.</li>
<li><b>stop zonal response matrix acquistion</b> (<code>zrespoff</code> in <code>Loop Configure</code> screen).</li>
</ul>
<p>The following files are then created:</p>
<hr/>
<p> File Archived location Description </p><hr/>
<p> <b>zrespmat.fits</b> zrespM/zrespM_${datestr}.fits zonal response matrix</p>
<p><b>wfsref0.fits</b> wfsref0/wfsref0_${datestr}.fits WFS reference (time-averaged image)</p>
<p><b>wfsmap.fits</b> wfsmap/wfsmap_${datestr}.fits Map of WFS elements sensitivity</p>
<p><b>dmmap.fits</b> dmmap/dmmap_${datestr}.fits Map of DM elements sensitivity</p>
<p><b>wfsmask.fits</b> wfsmask/wfsmask_${datestr}.fits WFS pixel mask, derived from wfsmap</p>
<p><b>dmmaskRM.fits</b> dmmaskRM/dmmaskRM_${datestr}.fits DM actuator mask, derived from dmmap by selecting actuators with strong response</p>
<p><b>dmslaved.fits</b> dmslaved/dmslaved_${datestr}.fits slaved DM actuators: actuators near active actuators in dmmaskRM</p>
<p><b>dmmask.fits</b> dmmask/dmmask_${datestr}.fits DM mask: all actuators controlled (union of dmmaskRM and dmslaved) </p><hr/>
<p>Note that at this point, the files are NOT loaded in shared memory, but the archieved file names are stored in the staging area "conf_zrm_staged/conf_streamname.txt" for future loading.</p>
<ul>
<li><b>Adopt staged configuration</b> (<code>upzrm</code> in <code>Loop Configure</code> screen)</li>
<li><b>Load zrespm files into shared memory</b> (<code>SMloadzrm</code> in <code>Loop Configure</code> screen)</li>
</ul>
<h2>Acquiring a modal response matrix (optional, for ZONAL DM only)</h2>
<p>In addition to the zonal response matrix, a modal response matrix can be acquired to improve sensitivity to low-oder modes.</p>
<p>To do so:</p>
<ul>
<li>activate <code>RMMon</code> to <b>toggle the modal RM on</b>.</li>
<li><b>select RM amplitude and maximum cycles per aperture (CPA)</b></li>
<li><b>start the acquisiton</b> (<code>LOresp_on</code>)</li>
<li><b>stop the acquisiton</b> (<code>LOresp_off</code>)</li>
</ul>
<p>The following files are then created:</p>
<hr/>
<p> File Archived location Description </p><hr/>
<p> <b>LOrespmat.fits</b> LOrespM/LOrespM_${datestr}.fits Modal response matrix</p>
<p><b>respM_LOmodes.fits</b> LODMmodes/LODMmodes_${datestr}.fits Low-order modes</p>
<p><b>LOwfsref0.fits</b> LOwfsref0/LOwfsref0_${datestr}.fits WFS reference measured during LO RM acquisition</p>
<p><b>LOwfsmap.fits</b> LOwfsmap/LOwfsmap_${datestr}.fits Map of WFS elements sensitivity</p>
<p><b>LOdmmap.fits</b> LOdmmap/LOdmmap_${datestr}.fits Map of DM elements sensitivity</p>
<p><b>LOwfsmask.fits</b> LOwfsmask/LOwfsmask_${datestr}.fits WFS pixel mask, derived from wfsmap</p>
<p><b>LOdmmask.fits</b> LOdmmask/LOdmmask_${datestr}.fits DM actuator mask, derived from dmmap by selecting actuators with strong response </p><hr/>
<p>Note that at this point, the files are NOT loaded in shared memory, but the archieved file names are stored in the staging area "conf_mrm_staged//conf_streamname.txt" for future loading.</p>
<ul>
<li><b>Adopt staged configuration</b> (<code>upmrm</code> in <code>Loop Configure</code> screen)</li>
<li><b>Load LOrespm files into shared memory</b> (<code>SMloadmrm</code> in <code>Loop Configure</code> screen)</li>
</ul>
<h2>Automatic system calibration (recommended)</h2>
<p>The automatic system calibration performs all steps listed above under zonal and modal response matrix acquisition.</p>
<p>The old calibrations are archived as follows:</p>
<ul>
<li>"conf_zrm_staged" and "conf_mrm_staged" hold the new configuration (zonal and modal respectively)</li>
<li>"conf_zrm_staged.000" and "conf_mrm_staged.000" hold the previous configuration (previously "conf_zrm_staged" and "conf_mrm_staged")</li>
<li>"conf_zrm_staged.001" and "conf_mrm_staged.001" hold the configuration previously named "conf_zrm_staged.000" and "conf_mrm_staged.000"</li>
<li>etc for a total of 20 configuration</li>
</ul>
<h2>Managing configurations</h2>
<p>At any given time, the current configuration (including control matrices if they have been computed) can be saved using the <code>SAVE CURRENT SYSTEM CALIBRATION</code> command. Saving a configuration will save all files in the conf directory into a user-specified directory.</p>
<p>Previously saved configurations can be loaded with the <code>LOAD SAVED SYSTEM CALIBRATION</code> command. This will load saved files into the conf directory and load all files into shared memory.</p>
<h1>Building control matrix</h1>
<ul>
<li><b>set SVDlimit</b> (<code>SVDla</code> in <code>Control Matrix</code> screen). Set value is 0.1 as a starting point for a stable loop.</li>
<li><b>perform full CM computation</b> (<code>mkModes0</code> in <code>Control Matrix</code> screen). Enter first the number of CPA blocks you wish to use. Computation takes a few minutes, and takes place in tmux session <code>aol::mkmodes</code>.</li>
</ul>
<p>The following files are created:</p>
<hr/>
<p> File Archived location Description </p><hr/>
<p> <b>aolN_DMmodes</b> Mmodes/DMmodes_${datestr}.fits DM modes</p>
<p><b>aolN_respM</b> respM/respM_${datestr}.fits WFS response to DM modes </p><hr/>
<p>Block-specific files:</p>
<hr/>
<p> File Archived location Description </p><hr/>
<p> <b>aolN_DMmodesbb</b> DMmodes/DMmodesbb_${datestr}.fits DM modes for block bb</p>
<p><b>aolN_respMbb</b> respM/respMbb_${datestr}.fits WFS response to DM modes for block bb</p>
<p><b>aolN_contrMbb.fits</b> contrM/contrMbb_${datestr}.fits Control matrix for block bb</p>
<p><b>aolN_contrMcbb.fits</b> contrMc/contrMcbb_${datestr}.fits Collapsed control matrix for block bb</p>
<p><b>aolN_contrMcactbb.fits</b> contrMcact/contrMcactbb_${datestr}.fits Collabsed control matrix for block bb, only active actuators </p><hr/>
<p>Note that at this point, the files are NOT loaded in shared memory, but the archieved file names are stored in "conf/conf_&lt;streamname&gt;.txt" for future loading.</p>
<ul>
<li><b>Load CM files into shared memory</b> (<code>SMloadCM</code> in <code>Control Matrix</code> screen)</li>
</ul>
<h1>Running the loop: Choosing hardware mode (CPU/GPU)</h1>
<p>There are multiple ways to perform the computations on CPU and/or GPUs. The main 3 parameters are:</p>
<ul>
<li><b>GPU</b> : 0 if matrix multiplication(s) done on CPU, &gt;0 for GPU use. This is the number GPUs to use for matrix mult.</li>
<li><b>CMmode</b> : 1 if using a combined matrix between WFS pixels and DM actuators, skipping intermediate computation of modes</li>
<li><b>GPUall</b> : if using GPUall, then the WFS reference subtraction is wrapped inside the GPU matrix multiplication</li>
</ul>
<hr/>
<p> GPU CMmode GPUall Matrix Features Description </p><hr/>
<p> &gt;0 ON ON contrMcact fastest dark-subtracted WFS frame imWFS0 is multiplited by collapsed control matrix (only active pixels). no mcoeff normalization and WFS reference subtraction are wrapped in this GPU operation as subtraction of pre-computed vector output. This is the fastest mode.</p>
<p>&gt;0 ON OFF contrMcact WFS reference is subtracted from imWFS0 in CPU, yielding imWFS2. imWFS2 is multiplied by control matrix (only active pixels) in GPU.</p>
<p>&gt;0 OFF OFF contrM MWFS reference is subtracted from imWFS0 in CPU, yiedling imWFS2. imWFS2 is multiplied (GPU) by control matrix to yield mode values. Mode coefficients then multiplied (GPU) by modes.</p>
<p>0 ON - contrMcact imWFS2 is multiplied by control matrix (only active pixels) in CPU</p>
<p>0 OFF - contrM imWFS2 multiplied by modal control matrix </p><hr/>
<h1>Auxilliary processes</h1>
<p>A number of auxilliary processes can be running in addition to the main loop operation.</p>
<h2>Extract WFS modes</h2>
<p>Launches script <code>./auxscripts/modesextractwfs</code> :</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;!INCLUDE &quot;../scripts/auxscripts/modesextractwfs&quot;</div>
</div><!-- fragment --><p>Converts WFS residuals into modes.</p>
<h2>Extract open loop modes</h2>
<p>Launches script C function (CPU-based):</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;key       :    aolcompolm</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;module    :    AOloopControl.c</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;info      :    compute open loop mode values</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;syntax    :    &lt;loop #&gt;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;example   :    aolcompolm 2</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;C call    :    long AOloopControl_ComputeOpenLoopModes(long loop)</div>
</div><!-- fragment --><p>This function is entirely modal, and assumes that the WFS modes (see section above) are computed. The key input to the function is <code>aolN_modeval</code>, the WFS residual mode values. The function uses this telemetry and knowledge of loop gain and mult factor to track open loop mode values.</p>
<p>Optionally, it also includes <code>aolN_modeval_pC</code>, the predictive control mode values that are added to the correction in predictive mode.</p>
<h2>Running average of dmC</h2>
<p>Launches script <code>./auxscripts/aol_dmCave 0.0005</code> :</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;!INCLUDE &quot;../scripts/auxscripts/aol_dmCave&quot;</div>
</div><!-- fragment --><h2>Compute and average wfsres</h2>
<p>Launches script <code>./auxscripts/aolmkWFSres 0.0005</code> :</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;!INCLUDE &quot;../scripts/auxscripts/aolmkWFSres&quot;</div>
</div><!-- fragment --><h1>Offsetting</h1>
<p>Input channels are provided to offset the AO loop convergence point. By default, <b>DM channels 04-11 can be dedicated to zero-point offsetting</b>. The DM channels are sym-linked to <code>aolN_dmZP0</code> - <code>aolN_dmZP7</code>.</p>
<div class="image">
<img src="./figures/aoloopctr_offset.jpg"  alt="WFS zero point offsetting" title="WFS zero point offsetting"/>
</div>
<p>Zero-point offsetting relies on two separate processes :</p>
<ul>
<li>Converting DM offsets to WFS offsets (can be done by CPU or GPU): aolN_dmZP -&gt; aolN_wfszpo</li>
<li>Summing and applying WFS offsets aolN_wfszpo to aolN_wfsref</li>
</ul>
<h2>Converting DM offsets to WFS offsets (zonal, CPU mode)</h2>
<p>CPU-based zero point offsets will compute WFS offsets from the zero point offset DM channels (04-11) and apply them to the <code>aolN_wfszpo#</code> stream.</p>
<ul>
<li><b>Activate CPU individual zero point offset channels</b> (<code>zplon0</code> to <code>zplon7</code>) to convert dm zero point displacements to wfs offsets.</li>
</ul>
<p>Every time one of the activated DM channel changes, the corresponding wfs <code>aolN_wfszpo#</code> zero point offset is CPU-computed.</p>
<p>The process runs inside tmux session <code>aolNzploop#</code></p>
<h2>Converting DM offsets to WFS offsets (zonal, GPU mode)</h2>
<p>A faster GPU-based zero point offset from DM to WFS is provided for each of the 8 offset channels. GPU-based and CPU-based offsetting for a single channel are mutually exclusive.</p>
<ul>
<li><b>Activate GPU individual zero point offset channels</b> (<code>GPUzplon0</code> to <code>GPUzplon7</code>) to convert dm zero point displacements to wfs offsets.</li>
</ul>
<p>Every time one of the activated DM channel changes, the corresponding wfs <code>aolN_wfszpo#</code> zero point offset is GPU-computed.</p>
<p>The process runs inside tmux session <code>aolNGPUzploop#</code></p>
<h2>Modal offsetting from another loop</h2>
<p>The two methods above are zonal offsetting: the DM map is multiplied by the zonal WFS response to compute WFS offset.</p>
<p>Modal offsetting, instead, relies on a pre-computed set of WFS modal offets. This is most useful when a separate control loop is driving modal offsets to the current loop.</p>
<p>To implement modal offsetting from a separate loop (refered to as the offsetting loop) :</p>
<ul>
<li>Configure the DM of the offsetting loop to write WFS zero point offsets to the current loop (see setting up DM section)</li>
<li>Do not activate either of the previous two zonal offsetting schemes</li>
<li>Activate the WFS offsets process (see next subsection)</li>
</ul>
<h2>Summing and applying WFS offsets to aolN_wfsref</h2>
<p>To activate WFS offsets to aolN_wfsref, the user needs to :</p>
<ul>
<li><b>Toggle the zero point offset loop process ON</b> (<code>LPzpo</code>) prior to starting the loop.</li>
</ul>
<p>Command <code>aolzpwfscloop</code> (C function <code>AOloopControl_WFSzeropoint_sum_update_loop</code>) launches a loop that monitors shared memory streams <code>aolN_wfszpo0</code> to <code>aolN_wfszpo7</code>, and updates the WFS reference when one of these has changed.</p>
<p>The loop is running inside tmux session <code>aolNwfszpo</code>, and is launched when the loop is closed (<code>Floopon</code>) if the loop zero point offset flag is toggled on (<code>LPzpo</code>)</p>
<h2>WFS average offset</h2>
<p>Measures average WFS residual with script : </p><pre class="fragment">./auxscripts/aolmkWFSres 0.0005
</pre><p>Running average is in stresm aol_wfsres_ave</p>
<h1>Controlling offsets from another loop</h1>
<h2>Running the loop</h2>
<p>The next steps are similar to the ones previously described, with the following important differences:</p>
<ul>
<li>The control matrix should be computed in zonal mode (no modal CPA block decomposition)</li>
</ul>
<h1>Predictive control (experimental)</h1>
<h2>Overview</h2>
<p>Predictive control is implemented in two processes:</p>
<ul>
<li>The optimal auto-regressive (AR) filter predicting the current state from previous states is computed. The AR filter is computed from open-loop estimates, so the processes computing open-loop telemetry need to be running.</li>
<li>the AR filter is applied to write a prediction buffer, which can be written asynchronously from the main loop steps.</li>
</ul>
<p>The predictive filter is modal, and adopts the same modes as the main control loop.</p>
<h2>Scripts</h2>
<hr/>
<p> File Description </p><hr/>
<p> <b>aolARPF</b> find auto-regressive predictive filter</p>
<p><b>aolARPFblock</b> AO find optimal AR linear predictive filter </p><hr/>
<h2>Data flow</h2>
<p>Predictive control is set up by blocks of modes. A block is configured through the aolconf predictive control sub-panel, which writes to configuration files <code>conf/conf_PFblock_XXX.txt</code>, where XXX is the block number (000, 001, 002 etc...). Configuration files specify the modes within each block (index min to index max), the predictive filter order, time lag and and averaging gain.</p>
<p>For each block, there are 3 main processes involved in running the predictive control:</p>
<ul>
<li><b>Watching input telemetry</b> this process listens to the input telemetry stream and periodically writes data to be used to compute a filter. This runs function <code>long AOloopControl_builPFloop_WatchInput(long loop, long PFblock)</code> in <code><a class="el" href="AOloopControl_8c.html" title="Adaptive Optics Control loop engine. ">AOloopControl.c</a></code>.</li>
<li><b>Computing filter</b>. Runs CLI command <code>mkARpfilt</code>, which runs function <code>LINARFILTERPRED_Build_LinPredictor</code> in <code><a class="el" href="linARfilterPred_8c.html" title="linear auto-regressive predictive filter ">linARfilterPred.c</a></code>.</li>
<li><b>Prediction engine</b> (= apply filter). Runs script <code>./auxscripts/predFiltApplyRT</code>.</li>
</ul>
<p>All 3 processes work in a chain, and can be turned on/off from the GUI.</p>
<h1>APPENDIX A: SHARED MEMORY STREAMS</h1>
<h2>Linking to existing stream</h2>
<p>Creates a sym link from an existing stream to a new stream. This is frequently used to connect to hardware (for example pointing aol8_wfsim to the WFS camera stream).</p>
<p>Within AOCCE, setting (new) stream aol::_&lt;deststream&gt; to point to &lt;srcstream&gt; involves:</p>
<ul>
<li>writing "\&lt;srcstream\&gt;" to file conf/streamlink_&lt;deststream&gt;.name.txt</li>
<li>removing any existing aol::_&lt;deststream&gt; stream</li>
<li>establishing sym link from &lt;srcstream&gt; to aol::_&lt;deststream&gt;</li>
</ul>
<p>The corresponding commands, to point aol8_wfsim to imcam, would be: </p><pre class="fragment">echo "imcam" &gt; conf/streamlink_wfsim.name.txt
rm /tmp/aol8_wfsim.im.shm
ln -s /tmp/imcam.im.shm /tmp/aol8_wfsim.im.shm
</pre><p>This is implemented in script : </p><pre class="fragment">./aolfuncs/aolfunc_StreamLink
</pre><h2>Loading images from FITS to shared memory stream</h2>
<h3>Overview</h3>
<p>Loading FITS file into a new or existing stream.</p>
<p>The recommended command to load a FITS image to shared memory in AOCCE is for example: </p><pre class="fragment">echo "./wfsref0/wfsref0_today.fits" &gt; ./conf/shmim_wfsref0.name.txt
Fits2shm -c -p aol${LOOPNUMBER}_ wfsref0
</pre><p>This command will skip loading if the stream does not need to be updated from the last load command. Add the -f option to force loading.</p>
<p>Options used: </p><pre class="fragment"> -c           read FITS file name from ./conf/shmim_&lt;streamname&gt;.name.txt directory
 -p &lt;pref&gt;    stream prefix
</pre><h3>Detailed description</h3>
<p>File name can be :</p>
<ul>
<li>option A: read from ./conf/shmim_&lt;stream&gt;.name.txt</li>
<li>option B: specfied and written to ./conf/shmim_&lt;stream&gt;.name.txt</li>
</ul>
<p>Command for option A: </p><pre class="fragment">Fits2shm &lt;FITS file&gt; &lt;stream&gt;
</pre><p>Command for option B: </p><pre class="fragment">Fits2shm -c &lt;stream&gt;
</pre><p>A prefix is usually added to the shared memory file with the -p option: </p><pre class="fragment">Fits2shm -c -p aol8_ &lt;stream&gt;
</pre><p>The -r removes/clears any previous instance of the stream and associated files: it is a stronger option than -f.</p>
<p>Fits2shm is located in the src/scripts/ directory of the AOCCE source code.</p>
<p>For both options, FITS files and shared memory files are inspected to assess need to load the image. If repetitive load requests are issued on the same file and shared memory, the script may decide that no action is required as the shared memory is already up-to-date.</p>
<p>Local directory ./loadedSM/ is used to keep track of streams loaded from FITS files.</p>
<p>Important files:</p>
<hr/>
<p> File Description </p><hr/>
<p> ./loadedSM/&lt;stream&gt;.FITSinfo FITS file name, size, time of last modification</p>
<p>./loadedSM/&lt;stream&gt;.FITSinfo.old previous version of above file - to be used for comparison</p>
<p>./loadedSM/&lt;stream&gt;.FITSsame File exists if the two FITS files are identical</p>
<p>./loadedSM/&lt;stream&gt;.FITSchanged File exists if the two FITS files are different</p>
<p>./loadedSM/&lt;stream&gt;.SMinfo stream file name, size, time of last modfification</p>
<p>./loadedSM/&lt;stream&gt;.SMinfo.old previous version of above file - to be used for comparison</p>
<p>./loadedSM/&lt;stream&gt;.SMsame File exists if the two SM files are identical</p>
<p>./loadedSM/&lt;stream&gt;.SMchanged File exists if the two SM files are different</p>
<p>./loadedSM/&lt;stream&gt;.imsize Image size - updated upon SM load</p>
<p>./loadedSM/&lt;stream&gt;.new File exists if last load request updated or created stream</p>
<p>./loadedSM/&lt;stream&gt;.kept File exists if last load request kept stream unchanged</p>
<p>./loadedSM/&lt;stream&gt;.missing File exists if last load request created new stream (stream was missing)</p>
<p>./conf/shmim_&lt;stream&gt;.name.txt FITS file name for stream</p>
<p>./conf/shmim_&lt;stream&gt;.imsize.txt Stream size</p>
<p>./conf/shmim_&lt;stream&gt;.fits (symbolic link to) FITS file</p>
<p>./tmp/&lt;prefix&gt;&lt;stream&gt;.im.shm File-mapped shared memory </p><hr/>
<p>The logic behind Fits2shm is as follows:</p>
<ul>
<li>Assume LOAD=0 (do not load FITS file in memory)</li>
<li>Check if FITS file has changed. If yes, set LOAD=1</li>
<li>Check if SM file has changed. If yes, set LOAD=1</li>
<li>Check if SM file exists, if not:<ul>
<li>set LOAD=1</li>
<li>create &lt;stream&gt;.missing file (otherwise, rm &lt;stream&gt;.missing file)</li>
</ul>
</li>
<li>Check if FORCE option, if yes, set LOAD=1</li>
<li>If LOAD=1:<ul>
<li>load file to shared memory</li>
</ul>
</li>
</ul>
<p>When loading :</p>
<ul>
<li>OPTION A only: update ./conf/shmim_&lt;stream&gt;_name.txt to the FITS file name</li>
<li>update ./loadedSM/&lt;stream&gt;.FITSinfo file</li>
<li>update ./loadedSM/&lt;stream&gt;.SMinfo file</li>
<li>create ./loadedSM/&lt;stream&gt;.kept OR ./loadedSM/&lt;stream&gt;.new file, remove the other one</li>
<li>create ./loadedSM/&lt;stream&gt;.missing file if the SM file did not exist, otherwise remove ./loadedSM/&lt;stream&gt;.missing</li>
<li>copy ./loadedSM/&lt;stream&gt;.imsize file to ./conf/shmim_&lt;stream&gt;.imsize.txt</li>
<li>load FITS file to ./tmp/&lt;prefix&gt;&lt;stream&gt;.im.shm</li>
<li>create sym link ./conf/shmim_&lt;stream&gt;.fits pointing to FITS file</li>
</ul>
<h1>APPENDIX B: CONF DIRECTORY</h1>
<h2>Overview</h2>
<p>The conf directory contains the following file types:</p>
<hr/>
<p> File Type Description </p><hr/>
<p> conf_XXXX.txt Information about the configuration (name etc...)</p>
<p>param_XXXXX.txt AOCCE parameter, usually written by GUI</p>
<p>streamlink_XXXX.txt shared memory link name for AOCCE stream XXXX</p>
<p>shmim_XXXX.name.txt Name of FITS file to be loaded to shared memory</p>
<p>shmim_XXXX.imsize.txt Image size of FITS file loaded to shared memory (written by Fits2shm)</p>
<p>shmim_XXXX.fits Sym link to FITS file loaded to shared memory (created by Fits2shm)</p>
<p>instconf_XXXXX.txt Instrument-specific configuration (filter wheels, stages.. ) </p><hr/>
<h2>Parameters</h2>
<h3>Overall and misc</h3>
<hr/>
<p> File Description </p><hr/>
<p> param_CPUset_mode.txt 1 if using CPUset</p>
<p>param_wfslambdanm.txt WFS wavelength [nm] </p><hr/>
<h3>Linear Hardware Simulator</h3>
<hr/>
<p> File Description </p><hr/>
<p> param_linsimDelay.txt Linear Hardware Simulator (LHS) hardware latency [us]</p>
<p>param_linsimdt.txt Linear Hardware Simulator (LHS) loop interval [us]</p>
<p>param_GPUlinsim.txt Linear Hardware Simulator (LHS) GPU index </p><hr/>
<h3>DM</h3>
<hr/>
<p> File Description </p><hr/>
<p> param_DMindex.txt DM index (00, 01, 02 ... )</p>
<p>param_DMMODE.txt ZONAL (default) or MODAL</p>
<p>param_DMxsize.txt DM x size</p>
<p>param_DMysize.txt DM y size</p>
<p>param_DM2DM_mode.txt DM-to-DM more. 1 if this DM drives another DM, 0 otherwise</p>
<p>param_DMwfsref_mode.txt 1 for CPU-based dmcomb DM ouput applied as WFS offset</p>
<p>param_DMvolt_mode.txt 1 if DM voltages applied (requires stream "dmvolt")</p>
<p>param_DMcombave_mode.txt DM averaging mode (default = 0)</p>
<p>param_DMdelayON.txt 1 if DM delay introduced</p>
<p>param_DMdelayus.txt DM delay value [us] </p><hr/>
<h3>Timing</h3>
<hr/>
<p> File Description </p><hr/>
<p> param_loopfrequ.txt WFS camera frequency [Hz]</p>
<p>param_hardwlatency.txt Hardware latency [s]</p>
<p>param_hardwlatency_frame.txt Hardware latency [frame]</p>
<p>param_complatency.txt Computation latency [s]</p>
<p>param_complatency_frame.txt Computation latency [frame]</p>
<p>param_wfsmextrlatency.txt Modal reconstruction latency [s]</p>
<p>param_wfsmextrlatency_frame.txt Modal reconstruction latency [frame]</p>
<p>param_nblatm.txt Number of cycles in latency measurement </p><hr/>
<h3>Response Matrix acquisition</h3>
<hr/>
<p> File Description </p><hr/>
<p> param_ACzrmtime.txt Max running time for zonal RM acquisition [s]</p>
<p>param_ACzrmNBcycle.txt Max number of cycles for zonal RM acquition</p>
<p>param_ACmrmtime.txt Max running time for monal RM acquisition [s]</p>
<p>param_ACmrmNBcycle.txt Max number of cycles for modal RM acquition</p>
<p>param_RMdelayfr.txt RM acquisition delay [frame]</p>
<p>param_RMfrave.txt RM acquisition number of frames averaged per poke</p>
<p>param_RMexft.txt RM acquisition number of frames excluded during poke transition</p>
<p>param_RMamplum.txt RM acquisition amplitude [um]</p>
<p>param_delayRM1us.txt RM acquisition delay 1 [s]</p>
<p>param_RMpokeMode.txt RM poking mode. 0=zonal, 1=Hadamard.</p>
<p>param_RMMamplum.txt RM Low Order Modal acquisition amplitude [um]</p>
<p>param_RMMcpa.txt RM Low Order Modal max CPA</p>
<p>param_WFSnorm.txt Normalize WFS frames</p>
<p>param_DMmaskRMp0.txt</p>
<p>param_DMmaskRMc0.txt</p>
<p>param_DMmaskRMp1.txt</p>
<p>param_DMmaskRMc1.txt</p>
<p>param_WFSmaskRMp0.txt</p>
<p>param_WFSmaskRMc0.txt</p>
<p>param_WFSmaskRMp1.txt</p>
<p>param_WFSmaskRMc1.txt</p>
<p>param_WFSmaskSNRr.txt</p>
<p>param_RMCalibReuseMasks.txt 1 if calibration masks reused (0 if re-computed)</p>
<p>param_.txt </p><hr/>
<h3>Modess and Control Matrix computation</h3>
<hr/>
<p> File Description </p><hr/>
<p> param_MASKS_LOCK.txt 1 if WFS and DM masks are locked</p>
<p>param_NBmodeblocks.txt Number of mode blocks (default=1) </p><hr/>
<h3>Loop Control</h3>
<hr/>
<p> File Description </p><hr/>
<p> param_DMprimWriteON.txt Primary Write ON/OFF (0 or 1)</p>
<p>param_CMMODE.txt Combined Matrix (0 or 1)</p>
<p>param_GPU.txt</p>
<p>param_GPUmodesextrwfs.txt WFS mode coefficients extraction: GPU device</p>
<p>param_GPUdmfwb.txt DM modal write (post-filtering): GPU device</p>
<p>param_GPUzpoffsetZ.txt Zonal WFS zero point offset loop: GPU device</p>
<p>param_GPUzpoffsetM.txt Modal WFS zero point offset loop: GPU device</p>
<p>param_LOOPPROCESS_EXTRWFSMODES.txt</p>
<p>param_LOOPPROCESS_EXTROLMODES.txt</p>
<p>param_LOOPPROCESS_DMFILTWB.txt</p>
<p>param_LOOPPROCESS_ZPO.txt</p>
<p>param_LOOPPROCESS_DMCAVE.txt</p>
<p>param_LOOPPROCESS_WFSRESAVE.txt</p>
<p>param_AUTOTUNELIMITS_ON.txt Autotuning ON/OFF (ON or OFF)</p>
<p>param_AUTOTUNELIMITmcoeff.txt Autotuning limits</p>
<p>param_AUTOTUNELIMITdelta.txt Autotuning limits</p>
<p>param_AUTOTUNEGAINS_ON.txt Autotuning gain (ON or OFF)</p>
<p>param_ARPFon.txt Auto-regressive predictive filter (ON or OFF)</p>
<p>param_ARPFg.txt Auto-regressive predictive filter gain</p>
<p>param_loopgain.txt</p>
<p>param_loopmmultcoeff.txt</p>
<p>param_loopmaxlim.txt Limit of DM actuators (direct write only)</p>
<hr/>
<h2>Stream Links</h2>
<hr/>
<p> File Description </p><hr/>
<p> streamlink_dmC.name.txt DM correction stream</p>
<p>streamlink_dmO.name.txt DM offset stream (DM flat channel)</p>
<p>streamlink_dmZP0.name.txt DM zero point offset #0 stream</p>
<p>streamlink_dmZP1.name.txt DM zero point offset #1 stream</p>
<p>streamlink_dmZP2.name.txt DM zero point offset #2 stream</p>
<p>streamlink_dmZP3.name.txt DM zero point offset #3 stream</p>
<p>streamlink_dmZP4.name.txt DM zero point offset #4 stream</p>
<p>streamlink_dmZP5.name.txt DM zero point offset #5 stream</p>
<p>streamlink_dmZP6.name.txt DM zero point offset #6 stream</p>
<p>streamlink_dmZP7.name.txt DM zero point offset #7 stream</p>
<p>streamlink_dmdisp.name.txt DM total displacement stream</p>
<p>streamlink_dmRM.name.txt DM response matrix stream</p>
<p>streamlink_dm2dmM.name.txt DM modes controlled in DM-to-DM mode (optional)</p>
<p>streamlink_dm2dmO.name.txt DM modes output in DM-to-DM mode (optional)</p>
<p>streamlink_dmwrefRM.name.txt WFS ref RM (optional)</p>
<p>streamlink_dmwrefO.name.txt WFS output (optional)</p>
<p>streamlink_wfsim.name.txt WFS image </p><hr/>
<h2>Shared memory FITS file initializations to streams</h2>
<p>File shmim_&lt;stream&gt;.name.txt contain the FITS file names that are loaded into shared memory streams aol&lt;loop&gt;_&lt;stream&gt;.</p>
<hr/>
<p> File Description </p><hr/>
<p> shmim_wfsdark.name.txt WFS dark</p>
<p>shmim_wfsmap.name.txt WFS response map</p>
<p>shmim_wfsmask.name.txt WFS mask</p>
<p>shmim_dmmap.name.txt</p>
<p>shmim_dmmaskRM.name.txt</p>
<p>shmim_dmslaved.name.txt</p>
<p>shmim_dmmask.name.txt</p>
<p>shmim_wfsref0.name.txt</p>
<p>shmim_zrespM.name.txt</p>
<p>shmim_LODMmodes.name.txt</p>
<p>shmim_LOrespM.name.txt</p>
<p>shmim_DModes.name.txt</p>
<p>shmim_respM.name.txt</p>
<p>shmim_contrM.name.txt</p>
<p>shmim_DMmodesXX.name.txt</p>
<p>shmim_respMXX.name.txt</p>
<p>shmim_contrMXX.name.txt</p>
<p>shmim_contrMcXX.name.txt</p>
<p>shmim_contrMcactXX_00.name.txt </p><hr/>
<h2>FITS files</h2>
<hr/>
<p> File Description </p><hr/>
<p> RMpokeCubeZ.fits.gz Simple Zonal poke mode</p>
<p>RM_DMmask.fits.gz mask for creating RM Hadamard pokes</p>
<p>Hpoke.fits.gz Hadamard poke modes</p>
<p>Hmat.fits.gz Hadamard-zonal transformation matrix</p>
<p>Hpixindex.fits.gz Hadamard DM pixel index</p>
<p>RMmat.fits.gz Current poke transformation matrix (optional)</p>
<p>RMpixindex.fits.gz Current DM pixel index</p>
<p>RMpokeCube.fits.gz Current poke modes </p><hr/>
<h1>REFERENCE: Content of ./status directory</h1>
<p>The status directories contrains the current state of the AOCCE processes.</p>
<hr/>
<p> File Description </p><hr/>
<p> stat_DMcombON.txt " ON" if DMcomb is running, "OFF" otherwise</p>
<p>stat_lsimON.txt " ON" if linear hardware simulator is running, "OFF" otherwise </p><hr/>
<h1>APPENDIX C: STEP-BY-STEP EXAMPLE</h1>
<h2>Starting the linear hardware simulator</h2>
<p><b>STEP 1</b>: Create directory <code>&lt;workdir&gt;</code></p>
<p><b>STEP 2</b>: Install scripts into <code>&lt;workdir&gt;</code>: </p><pre class="fragment">cd &lt;srcdir&gt;/src/AOloopControl/scripts
syncscripts -e &lt;workdir&gt;
cd &lt;workdir&gt;
./syncscripts
</pre><p><b>STEP 3</b>: Download a calibration, consisting of zonal response matrix and a WFS reference. Place the file in a new directory <code>&lt;workdir&gt;/simLHS</code></p>
<p><b>STEP 4</b>: Launch aolconf, loop number 5, loop name simtest: </p><pre class="fragment">./aolconf -L 5 -N simtest
</pre><p>Note that you subsequent calls to aolconf should then be without the -L and -N options.</p>
<p><b>STEP 5</b>: Set DM size to match the calibration. <code>dmxs</code> and <code>dmys</code> GUI top menu.</p>
<p><b>STEP 6</b>: Autoconfigure DM: <code>dmnolink</code> in GUI top menu.</p>
<p><b>STEP 7</b>: Turn off dmvolt: <code>dmvolt0</code> in GUI top menu.</p>
<p><b>STEP 8</b>: Set DM averaging mode to 2: <code>dmcombam</code> in GUI top menu.</p>
<p><b>STEP 9</b>: Start DMcomb. <code>initDM</code> in GUI top menu.</p>
<p><b>STEP 10</b>: Load all memory. <code>M</code> in GUI top menu</p>
<p><b>STEP 11</b>: Link LHS files</p>
<p><b>STEP 12</b>: Start the LHS process</p>
<h2>Acquiring calibration, compute control matrix</h2>
<p>Under configuration GUI menu :</p>
<ul>
<li>Measure hardware timing: <code>mlat</code></li>
<li>set Hadamard mode to ON: <code>Hon</code></li>
<li>set RM modal to ON: <code>RMMon</code></li>
<li>Acquire automatic calibration: <code>nAUTOc</code></li>
</ul>
<p>Under control matrix GUI menu :</p>
<ul>
<li>Select maximum control spatial frequency: <code>modeCPA</code></li>
<li>Create modes and control matrix: <code>mkModes0</code></li>
<li>update configuration: <code>confUp</code></li>
</ul>
<p>Load and manage configuration :</p>
<ul>
<li>load configuration</li>
<li>save configuration</li>
</ul>
<h1>APPENDIX D: Managing multiple processes</h1>
<p>Note: Here, a process can consist of any operation or set of operations, as defined by the user. In this appendix, a process does not strictly correspond to a CPU process.</p>
<p>AOCCE's bash script includes tools to manage logical links between processes. A process can be <b>queued</b>, waiting to start until some condition is met, and its status (running, waiting to be launched, or completed) can be checked.</p>
<p>The command <code>l</code> under the GUI top menu will launch a window displaying processes status.</p>
<h2>Queued process</h2>
<p>A queued process is a process that has been sent to a tmux session but is awaiting previous operations, within the same tmux session, to be completed. The process is logged as queued when the corresponding command is sent to the tmux session. When the tmux session reaches the command, it will move it from queued to active.</p>
<p>To log queued processes as such, follow this bash template: </p><pre class="fragment">logRunningProcessQ "&lt;process_tag&gt;" &lt;tmux_session_name&gt;
tmux send-keys -t &lt;tmux_session_name&gt; "process_command" C-m
</pre><p>or </p><pre class="fragment">logRunningProcessQ0 "&lt;process_tag&gt;" &lt;tmux_session_name&gt; "&lt;comments&gt;"
tmux send-keys -t &lt;tmux_session_name&gt; "mv runproc/&lt;process_tag&gt;.runprocQ runproc/&lt;process_tag&gt;.runproc" C-m
tmux send-keys -t &lt;tmux_session_name&gt; "process_command" C-m
</pre><p><code>process_tag</code> is a name chosen to represent the operations performed. The second option can be used when writing to a script, so it is more flexible.</p>
<h2>Active process</h2>
<p>To mark a process as active, it can either be queued as described above, or the user can include at the time the process starts: </p><pre class="fragment">touch runproc/&lt;process_tag&gt;.runproc
</pre><p>Once the process is completed, it needs to be removed from the active process list : </p><pre class="fragment">rm runproc/&lt;process_tag&gt;.runproc
</pre><h2>Locking/unlocking processes</h2>
<p>The command <code>./auxscripts/waitforfilek</code> in <code>&lt;srcdir&gt;/scripts</code> locks the bash script execution until a file <code>&lt;tagname&gt;.unlock</code> appears. The command will remove the unlock file once it appears, and continue execution. It can take a timeout option. Typical use: </p><pre class="fragment">tmux send-keys -t &lt;tmux_session_name&gt; "command_that_needs_to_be_completed_before_non-tmux_script_commands" C-m
tmux send-keys -t &lt;tmux_session_name&gt; "touch &lt;tagname&gt;.unlock" C-m  # command will unlock the script once the unlock file appears
./auxscripts/waitforfilek -t &lt;timeout_sec&gt; &lt;tagname&gt;
&lt;non-tmux_script_commands_to_be_executed_AFTER_tmux_commands&gt;
</pre><p>The command creates a "&lt;tagname&gt;.lock" file, and waits for a "&lt;tagname&gt;.unlock" to appear. When the unlock file is detected, both lock and unlock files are removed. The lock file indicates that a process is currently locked. This scheme can be employed to synchronize multiple scripts.</p>
<p>The lower level <code>./auxscripts/waitonfile</code> command allows users to manually setup locks between proceses, by waiting for a file to disappear. Typical use: </p><pre class="fragment">touch fname.lock
&lt;some other process here, will remove fname.lock file when done&gt;
./auxscripts/waitonfile fname.lock
&lt;more bash instructions here&gt;</pre> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Jan 3 2018 19:25:36 for cacao by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
